

--// library script private
if not getgenv().moon then
getgenv().namehub = "Viridian | .gg/getviridian" else
getgenv().namehub = "Moon | .gg/moondiety"
end

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/wzaxk/check/refs/heads/main/uiloader"))()

local main = Library.new()

local tab0 = main:create_tab('Main')
local tab2 = main:create_tab('Utility')
local tab = main:create_tab('Teleport')
local tab3 = main:create_tab('ESP')


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ToolDamageObject = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("ToolDamageObject")
local Workspace = game:GetService("Workspace")

local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local itemsFolder = Workspace:WaitForChild("Items")
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")

local campfireDropPos = Vector3.new(0, 19, 0)
local campfireFuelItems = { "Log", "Coal", "Fuel Canister", "Oil Barrel", "Biofuel" }

local greedyFuelEnabled = {}
local autoFuelEnabled = {}

local function moveItemToCampfire(item)
    local part = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")
    if not part then return end
    if not item.PrimaryPart then
        pcall(function() item.PrimaryPart = part end)
    end
    pcall(function()
        remoteEvents.RequestStartDraggingItem:FireServer(item)
        task.wait(0.05)
        item:SetPrimaryPartCFrame(CFrame.new(campfireDropPos))
        task.wait(0.05)
        remoteEvents.StopDraggingItem:FireServer(item)
    end)
end

local function processFuel(enabledTable)
    for name, enabled in pairs(enabledTable) do
        if enabled then
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == name then
                    moveItemToCampfire(item)
                end
            end
        end
    end
end

local greedyDrop = tab0.create_multidropdown({
    name = "Greedy Fuel",
    flag = "greedy_fuel_dropdown",
    section = "left",
    option = "Select fuels",
    options = campfireFuelItems,
    multi = true,
    callback = function(selected)
     
        for _, name in ipairs(campfireFuelItems) do
            greedyFuelEnabled[name] = false
        end
        for _, name in ipairs(selected) do
            greedyFuelEnabled[name] = true
        end
    end
})

local autoDrop = tab0.create_multidropdown({
    name = "Auto Fuel",
    flag = "auto_fuel_dropdown",
    section = "left",
    option = "Select fuels",
    options = campfireFuelItems,
    multi = true,
    callback = function(selected)
        for _, name in ipairs(campfireFuelItems) do
            autoFuelEnabled[name] = false
        end
        for _, name in ipairs(selected) do
            autoFuelEnabled[name] = true
        end
    end
})

coroutine.wrap(function()
    while true do
        processFuel(greedyFuelEnabled)
        task.wait(2)
    end
end)()

coroutine.wrap(function()
    local campfire = Workspace:WaitForChild("Map"):WaitForChild("Campground"):WaitForChild("MainFire")
    local fill = campfire.Center.BillboardGui.Frame.Background.Fill
    while true do
        local hp = fill.Size.X.Scale
        if hp < 0.7 then
            repeat
                processFuel(autoFuelEnabled)
                task.wait(0.5)
                hp = fill.Size.X.Scale
            until hp >= 1
        end
        task.wait(2)
    end
end)()

local itemsFolder = workspace:WaitForChild("Items")
local remoteEvents = game.ReplicatedStorage:WaitForChild("RemoteEvents")

local machineDropPos = Vector3.new(21, 16, -5)

local craftableItems = {
    "UFO Junk", "UFO Component", "Old Car Engine", "Broken Fan",
    "Old Microwave", "Bolt", "Log", "Cultist Gem", "Sheet Metal",
    "Old Radio", "Tyre", "Washing Machine", "Cultist Experiment",
    "Cultist Component", "Gem of the Forest Fragment", "Broken Microwave"
}

local enabledCraftItems = {}

-- prepend "All" option
local dropdownOptions = table.clone(craftableItems)
table.insert(dropdownOptions, 1, "All")

tab0.create_multidropdown({
    name = "Auto Craft Items",
    flag = "autocraft_items",
    section = "left",
    option = "None Selected",
    options = dropdownOptions,

    callback = function(selected)
        table.clear(enabledCraftItems)

        if table.find(selected, "All") then
            for _, item in ipairs(craftableItems) do
                enabledCraftItems[item] = true
            end
        else
            for _, itemName in ipairs(selected) do
                enabledCraftItems[itemName] = true
            end
        end
    end
})

local function moveItemToMachine(item)
    local part = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")
    if not part then return end

    if not item.PrimaryPart then
        pcall(function() item.PrimaryPart = part end)
    end

    pcall(function()
        remoteEvents.RequestStartDraggingItem:FireServer(item)
        task.wait(0.05)
        item:SetPrimaryPartCFrame(CFrame.new(machineDropPos))
        task.wait(0.05)
        remoteEvents.StopDraggingItem:FireServer(item)
    end)
end

coroutine.wrap(function()
    while true do
        for itemName, _ in pairs(enabledCraftItems) do
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == itemName then
                    moveItemToMachine(item)
                end
            end
        end
        task.wait(2.5)
    end
end)()

local itemsFolder = workspace:WaitForChild("Items")
local remoteEvents = game.ReplicatedStorage:WaitForChild("RemoteEvents")

local biofuelItems = {
    "Carrot", "Cooked Morsel", "Morsel", "Steak", "Cooked Steak", "Log"
}

local enabledBiofuelItems = {}

local dropdownOptions = table.clone(biofuelItems)
table.insert(dropdownOptions, 1, "All")

tab0.create_multidropdown({
    name = "Auto Biofuel",
    flag = "autobiofuel_items",
    section = "left",
    option = "None Selected",
    options = dropdownOptions,

    callback = function(selected)
        table.clear(enabledBiofuelItems)

        if table.find(selected, "All") then
            for _, item in ipairs(biofuelItems) do
                enabledBiofuelItems[item] = true
            end
        else
            for _, item in ipairs(selected) do
                enabledBiofuelItems[item] = true
            end
        end
    end
})

local function moveItemTo(pos, item)
    local part = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")
    if not part then return end

    if not item.PrimaryPart then
        pcall(function() item.PrimaryPart = part end)
    end

    pcall(function()
        remoteEvents.RequestStartDraggingItem:FireServer(item)
        task.wait(0.05)
        item:SetPrimaryPartCFrame(CFrame.new(pos))
        task.wait(0.05)
        remoteEvents.StopDraggingItem:FireServer(item)
    end)
end

coroutine.wrap(function()
    local processorPos = nil

    while true do
        if not processorPos then
            local processor = workspace:FindFirstChild("Structures")
                and workspace.Structures:FindFirstChild("Biofuel Processor")
            local part = processor and processor:FindFirstChild("Part")
            if part then
                processorPos = part.Position + Vector3.new(0, 5, 0)
            end
        end

        if processorPos then
            for itemName, _ in pairs(enabledBiofuelItems) do
                for _, item in ipairs(itemsFolder:GetChildren()) do
                    if item.Name == itemName then
                        moveItemTo(processorPos, item)
                    end
                end
            end
        end

        task.wait(2)
    end
end)()

local itemsFolder = workspace:WaitForChild("Items")
local remoteConsume = game.ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestConsumeItem")

local autoEatFoods = { "Cooked Steak", "Cooked Morsel", "Berry", "Carrot", "Apple" }

local autoEatEnabled = false
local autoEatHPEnabled = false
local autoFuelEnabled = false

local eatDelay = 3
local hpThreshold = 0.5
local fuelDelay = 5

tab0.create_toggle({
    name = "Auto Eat (Time Based)",
    flag = "auto_eat_time",
    section = "left",
    enabled = false,
    callback = function(state)
        autoEatEnabled = state
    end
})

tab0.create_slider({
    name = "Eat Delay (seconds)",
    flag = "eat_delay",
    section = "left",
    value = 3,
    minimum_value = 1,
    maximum_value = 10,
    callback = function(value)
        eatDelay = value
    end
})

tab0.create_toggle({
    name = "Auto Eat (HP Based)",
    flag = "auto_eat_hp",
    section = "left",
    enabled = false,
    callback = function(state)
        autoEatHPEnabled = state
    end
})

tab0.create_slider({
    name = "Eat if Hunger Below (%)",
    flag = "eat_hunger_threshold",
    section = "left",
    value = 50,
    minimum_value = 10,
    maximum_value = 100,
    callback = function(value)
        hpThreshold = value / 100
    end
})


coroutine.wrap(function()
    while true do
        if autoEatEnabled then
            local foodList = {}
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if table.find(autoEatFoods, item.Name) then
                    table.insert(foodList, item)
                end
            end

            if #foodList > 0 then
                local food = foodList[math.random(1, #foodList)]
                pcall(function() remoteConsume:InvokeServer(food) end)
            end
        end
        task.wait(eatDelay)
    end
end)()

local player = game.Players.LocalPlayer
local hungerBar = player:WaitForChild("PlayerGui"):WaitForChild("Interface")
    :WaitForChild("StatBars"):WaitForChild("HungerBar"):WaitForChild("Bar")

coroutine.wrap(function()
    while true do
        if autoEatHPEnabled then
            if hungerBar.Size.X.Scale <= hpThreshold then
                repeat
                    local foodList = {}
                    for _, item in ipairs(itemsFolder:GetChildren()) do
                        if table.find(autoEatFoods, item.Name) then
                            table.insert(foodList, item)
                        end
                    end

                    if #foodList > 0 then
                        local food = foodList[math.random(1, #foodList)]
                        pcall(function() remoteConsume:InvokeServer(food) end)
                    else
                        break
                    end

                    task.wait(1)
                until hungerBar.Size.X.Scale >= 0.99 or not autoEatHPEnabled
            end
        end
        task.wait(3)
    end
end)()


 
local treeFarmActive = false

local function getAllTrees()
    local map = Workspace:FindFirstChild("Map")
    if not map then return {} end
    local landmarks = map:FindFirstChild("Landmarks") or map:FindFirstChild("Foliage")
    if not landmarks then return {} end

    local trees = {}
    for _, tree in ipairs(landmarks:GetChildren()) do
        if tree.Name == "Small Tree" and tree:IsA("Model") then
            local trunk = tree:FindFirstChild("Trunk") or tree.PrimaryPart
            if trunk then
                table.insert(trees, {tree = tree, trunk = trunk})
            end
        end
    end
    return trees
end

local function getAxe()
    local inv = LocalPlayer:FindFirstChild("Inventory")
    if not inv then return nil end
    return inv:FindFirstChild("Old Axe") or inv:FindFirstChildWhichIsA("Tool")
end

local function startTreeFarm()
    if treeFarmActive then return end
    treeFarmActive = true

    task.spawn(function()
        while treeFarmActive do
            local trees = getAllTrees()
            for _, t in ipairs(trees) do
                if not treeFarmActive then break end
                local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp and t.trunk then
                   
                    local treeCFrame = t.trunk.CFrame
                    local rightVector = treeCFrame.RightVector
                    local targetPosition = treeCFrame.Position + rightVector * 3
                    hrp.CFrame = CFrame.new(targetPosition)
                    task.wait(0.25)

                    local axe = getAxe()
                    if axe then
                        if axe.Parent == LocalPlayer.Backpack then
                            axe.Parent = char
                            task.wait(0.15)
                        end

                        while t.tree.Parent and treeFarmActive do
                            pcall(function() axe:Activate() end)
                            local args = {
                                t.tree,
                                axe,
                                "1_8264699301",
                                t.trunk.CFrame
                            }
                            pcall(function() ToolDamageObject:InvokeServer(unpack(args)) end)
                            task.wait(1)
                        end
                    end
                end
                task.wait(0.5)
            end
            task.wait(1)
        end
    end)
end

local function stopTreeFarm()
    treeFarmActive = false
end
getgenv().autofarm=false
tab2.create_button({
    name = 'Auto Tree/Bunny Farm (requires axe in hand)',
    flag = 'AutoTreeFarmFlag',
    section = 'left',
    enabled = false,

    callback = function(state: boolean)
    local Noclip = nil
local Clip = nil

function noclip()
    Clip = false
    local function Nocl()
        if Clip == false and game.Players.LocalPlayer.Character ~= nil then
            for _,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if v:IsA('BasePart') and v.CanCollide and v.Name ~= floatName then
                    v.CanCollide = false
                end
            end
        end
        wait(0.21) -- basic optimization
    end
    Noclip = game:GetService('RunService').Stepped:Connect(Nocl)
end

function clip()
    if Noclip then Noclip:Disconnect() end
    Clip = true
end
 noclip()
 local l = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
if state then task.wait(2) getgenv().autofarm=state end 

while getgenv().autofarm and task.wait() do
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

    local x = camera.ViewportSize.X / 2
    local y = camera.ViewportSize.Y / 2

    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 0)

    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 0)
 


local VirtualUser = game:service("VirtualUser")
game:GetService("Players").LocalPlayer.Idled:Connect(function()
    VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    task.wait()
    VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
end)

game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = l + Vector3.new(0,30,0)

local lp = game:GetService("Players").LocalPlayer
local char = lp.Character or lp.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local targetCF = hrp.CFrame + Vector3.new(0, 10, 0)
local foundTree = false
local foundBunny = false

local function tpModel(model)
    local boxCF = model:GetBoundingBox()
    local offset = targetCF.Position - boxCF.Position
    for _, part in pairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CFrame = part.CFrame + offset
        end
    end
end

local function tpFolder(folder)
    for _, obj in pairs(folder:GetDescendants()) do
        if obj.Name == "Small Tree" then
            foundTree = true
            if obj:IsA("Model") then
                tpModel(obj)
            elseif obj:IsA("BasePart") then
                obj.CFrame = targetCF
            end
        end
    end
end

local map = workspace:WaitForChild("Map")
if map:FindFirstChild("Landmarks") then tpFolder(map.Landmarks) end
if map:FindFirstChild("Foliage") then tpFolder(map.Foliage) end

for _, obj in pairs(workspace:WaitForChild("Characters"):GetChildren()) do
    if obj.Name == "Bunny" and obj:FindFirstChild("HumanoidRootPart") then
        foundBunny = true
        obj.HumanoidRootPart.CFrame = hrp.CFrame
    end
end

if not foundTree and not foundBunny then
    clip()
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(7.93, 4.00, 3.69)
    getgenv().autofarm=false
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(7.93, 4.00, 3.69)

end

end
    end
})


tab2.create_button({
    name = 'Instant Interact',
    flag = 'Bringlog',

    section = 'left',
    enabled = false,

    callback = function(state: boolean)
      local function setupPrompt(p)
                if p:IsA("ProximityPrompt") then
                    p.RequiresLineOfSight = false
                    p.MaxActivationDistance = 15
                    p.HoldDuration = 0
                   
                end
            end

            for _, p in ipairs(workspace:GetDescendants()) do setupPrompt(p) end
            workspace.DescendantAdded:Connect(setupPrompt)
    end
})
tab.create_button({
    name = 'Teleport To Camp',
    flag = 'Bringlog',

    section = 'left',
    enabled = false,

    callback = function(state: boolean)
      local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HRP = Character:WaitForChild("HumanoidRootPart")

HRP.CFrame = CFrame.new(
    13.287363052368164, 3.999999761581421, 0.36212217807769775,
    0.6022269129753113, -2.275036159460342e-08, 0.7983249425888062,
    6.430457055728311e-09, 1, 2.364672191390582e-08,
    -0.7983249425888062, -9.1070981866892e-09, 0.6022269129753113
)
    end
})
tab.create_button({
    name = 'Teleport To Trader',
    flag = 'Bringlog',

    section = 'left',
    enabled = false,

    callback = function(state: boolean)
    local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HRP = Character:WaitForChild("HumanoidRootPart")

local traderPos = Vector3.new(-37.08, 3.98, -16.33)
HRP.CFrame = CFrame.new(traderPos)
    end
})
tab.create_button({
    name = 'Teleport To Random Tree',
    flag = 'Bringlog',
    section = 'left',
    callback = function()
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local Workspace = game:GetService("Workspace")

        local function teleportToRandomTree()
            local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local map = Workspace:FindFirstChild("Map")
            if not map then return end

            local foliage = map:FindFirstChild("Foliage") or map:FindFirstChild("Landmarks")
            if not foliage then return end

            local trees = {}
            for _, obj in ipairs(foliage:GetChildren()) do
                if obj.Name == "Small Tree" and obj:IsA("Model") then
                    local trunk = obj:FindFirstChild("Trunk") or obj.PrimaryPart
                    if trunk then
                        table.insert(trees, trunk)
                    end
                end
            end

            if #trees > 0 then
                local trunk = trees[math.random(1, #trees)]
                local treeCFrame = trunk.CFrame
                local rightVector = treeCFrame.RightVector
                local targetPosition = treeCFrame.Position + rightVector * 3
                hrp.CFrame = CFrame.new(targetPosition)
            end
        end

        teleportToRandomTree()
    end
})



local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local itemFolder = Workspace:WaitForChild("Items")

local savedPositions = {}
local itemDropdown

local function getSortedUniqueNames()
    local found = {}
    for _, item in ipairs(itemFolder:GetChildren()) do
        if item:IsA("Model") and item:GetPivot() then
            found[item.Name] = true
        end
    end
    local list = {}
    for name in pairs(found) do
        table.insert(list, name)
    end
    table.sort(list)
    return list
end

itemDropdown = tab.create_multidropdown({
    name = 'Teleport Items',
    flag = 'item_tp_dropdown',
    section = 'left',
    option = 'Select Items',
    options = getSortedUniqueNames(),

    callback = function(selected)
        for _, item in ipairs(itemFolder:GetChildren()) do
            if item:IsA("Model") and item:GetPivot() then
                local isSelected = table.find(selected, item.Name) ~= nil

                if isSelected and not savedPositions[item] then
                    savedPositions[item] = item:GetPivot()
                    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local newCFrame = CFrame.new(hrp.Position + Vector3.new(0, 5, 0))
                        item:PivotTo(newCFrame)
                    end
                elseif not isSelected and savedPositions[item] then
                    item:PivotTo(savedPositions[item])
                    savedPositions[item] = nil
                end
            end
        end
    end
})

function itemDropdown:Refresh()
    self.options = getSortedUniqueNames()
    self:update()
end

itemFolder.ChildAdded:Connect(function()
    task.wait(0.1)
    itemDropdown:Refresh()
end)

itemFolder.ChildRemoved:Connect(function()
    task.wait(0.1)
    itemDropdown:Refresh()
end)
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer
local characterFolder = Workspace:WaitForChild("Characters")

local selectedNames = {}
local savedPositions = {}
local characterDropdown

local function getSortedUniqueCharacterNames()
	local found = {}
	for _, char in ipairs(characterFolder:GetChildren()) do
		if char:IsA("Model") and char:GetPivot() then
			found[char.Name] = true
		end
	end
	local list = {"All"}
	for name in pairs(found) do
		table.insert(list, name)
	end
	table.sort(list, function(a,b)
		if a == "All" then return true
		elseif b == "All" then return false
		else return a < b
		end
	end)
	return list
end

local function disableCollision(model)
	for _, part in ipairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide = false
		end
	end
end

characterDropdown = tab.create_multidropdown({
	name = 'Teleport Characters',
	flag = 'character_tp_dropdown',
	section = 'left',
	option = 'Select Characters',
	options = getSortedUniqueCharacterNames(),

	callback = function(selected)
		selectedNames = selected
	end
})

function characterDropdown:Refresh()
	self.options = getSortedUniqueCharacterNames()
	self:update()
end

characterFolder.ChildAdded:Connect(function()
	task.wait(0.1)
	characterDropdown:Refresh()
end)

characterFolder.ChildRemoved:Connect(function()
	task.wait(0.1)
	characterDropdown:Refresh()
end)

RunService.RenderStepped:Connect(function()
	local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local allSelected = table.find(selectedNames, "All") ~= nil

	for _, char in ipairs(characterFolder:GetChildren()) do
		if char:IsA("Model") and char:GetPivot() then
			local name = char.Name
			local isSelected = allSelected or table.find(selectedNames, name) ~= nil
			local pivot = char:GetPivot()

			if isSelected then
				if not savedPositions[char] then
					savedPositions[char] = pivot
				end
				char:PivotTo(CFrame.new(hrp.Position + Vector3.new(0,4,0)))
				disableCollision(char)
			else
				if savedPositions[char] then
					char:PivotTo(savedPositions[char])
					savedPositions[char] = nil
				end
			end
		end
	end
end)

local ESPEnabled = false
local ESPFolder = {}
local tracers = {}
local billboardTags = {}
local espConnection = nil
local scanTask = nil

tab3.create_toggle({
    name = 'Entity ESP',
    flag = 'Bringlog',
    section = 'left',
    enabled = false,

    callback = function(state: boolean)
        ESPEnabled = state

        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local Workspace = game:GetService("Workspace")
        local Camera = Workspace.CurrentCamera
        local LocalPlayer = Players.LocalPlayer

        local espSettings = {
            PlayerESP = true,
            Fairy = false,
            Wolf = false,
            Bunny = false,
            Cultist = false,
            CrossBow = false,
            PeltTrader = false,
            NameColor = Color3.fromRGB(255, 255, 255),
            NameSize = 16,
            HPBarSize = Vector2.new(60, 6),
            BillboardOverheadNames = true,
            MaxDistance = 500
        }

        local function createBillboard(model)
            if billboardTags[model] then return end
            local head = model:FindFirstChild("Head")
            if not head then return end

            local gui = Instance.new("BillboardGui")
            gui.Name = "NameTag"
            gui.Adornee = head
            gui.AlwaysOnTop = true
            gui.Size = UDim2.new(0, 100, 0, 20)
            gui.StudsOffset = Vector3.new(0, 2, 0)

            local label = Instance.new("TextLabel")
            label.Parent = gui
            label.Size = UDim2.new(1, 0, 1, 0)
            label.BackgroundTransparency = 1
            label.Text = model.Name
            label.TextColor3 = espSettings.NameColor
            label.TextStrokeTransparency = 0.5
            label.TextScaled = true
            label.Font = Enum.Font.SourceSansBold

            gui.Parent = head
            billboardTags[model] = gui
        end

        local function removeBillboards()
            for model, gui in pairs(billboardTags) do
                if gui and gui.Parent then
                    gui:Destroy()
                end
            end
            billboardTags = {}
        end

        local function createESP(model)
            if ESPFolder[model] then return end
            local head = model:FindFirstChild("Head") or model:FindFirstChildWhichIsA("BasePart")
            if not head then return end

            ESPFolder[model] = {
                head = head,
                name = Drawing.new("Text"),
                hpBack = Drawing.new("Square"),
                hpBar = Drawing.new("Square"),
                model = model
            }

            local d = ESPFolder[model]
            d.name.Size = espSettings.NameSize
            d.name.Center = true
            d.name.Outline = true
            d.name.Color = espSettings.NameColor
            d.name.Visible = false

            d.hpBack.Color = Color3.new(0, 0, 0)
            d.hpBack.Filled = true
            d.hpBack.Transparency = 0.7
            d.hpBack.Visible = false

            d.hpBar.Color = Color3.new(0, 1, 0)
            d.hpBar.Filled = true
            d.hpBar.Transparency = 0.9
            d.hpBar.Visible = false
        end

        local function clearESP()
            for _, data in pairs(ESPFolder) do
                if data.name then data.name:Remove() end
                if data.hpBack then data.hpBack:Remove() end
                if data.hpBar then data.hpBar:Remove() end
            end
            ESPFolder = {}

            for _, line in pairs(tracers) do
                line:Remove()
            end
            tracers = {}

            removeBillboards()
        end

        if ESPEnabled then
            scanTask = task.spawn(function()
                while ESPEnabled do
                    task.wait(1)
                    for _, model in pairs(workspace:GetDescendants()) do
                        if model:IsA("Model") and model:FindFirstChild("Head") then
                            if not ESPFolder[model] and (Players:GetPlayerFromCharacter(model) or model:IsDescendantOf(workspace.Characters)) then
                                createESP(model)
                            end
                        end
                        if model:IsA("Model") and model:IsDescendantOf(workspace.Characters) and not billboardTags[model] and espSettings.BillboardOverheadNames then
                            createBillboard(model)
                        end
                    end
                end
            end)

            espConnection = RunService.Heartbeat:Connect(function(dt)
                for i = #tracers, 1, -1 do
                    tracers[i].Visible = false
                end

                local screenMid = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                local i = 1

                for model, data in pairs(ESPFolder) do
                    local head = data.head
                    if not model:IsDescendantOf(workspace) then
                        data.name:Remove()
                        data.hpBack:Remove()
                        data.hpBar:Remove()
                        ESPFolder[model] = nil
                        continue
                    end

                    local isPlayer = Players:GetPlayerFromCharacter(model)
                    local visible = false
                    local labelText = ""
                    local dist = (Camera.CFrame.Position - head.Position).Magnitude

                    if dist > espSettings.MaxDistance then
                        data.name.Visible = false
                        data.hpBack.Visible = false
                        data.hpBar.Visible = false
                        continue
                    end

                    if isPlayer and espSettings.PlayerESP then
                        labelText = model.Name .. " {" .. math.floor(dist) .. "m}"
                        visible = true
                    elseif not isPlayer then
                        local n = model.Name:lower()
                        if espSettings.Fairy and n:find("fairy") then
                            labelText = "Fairy {" .. math.floor(dist) .. "m}"
                            visible = true
                        elseif espSettings.Wolf and (n:find("wolf") or n:find("alpha")) then
                            labelText = "Wolf {" .. math.floor(dist) .. "m}"
                            visible = true
                        elseif espSettings.Bunny and n:find("bunny") then
                            labelText = "Bunny {" .. math.floor(dist) .. "m}"
                            visible = true
                        elseif espSettings.Cultist and n:find("cultist") and not n:find("cross") then
                            labelText = "Cultist {" .. math.floor(dist) .. "m}"
                            visible = true
                        elseif espSettings.CrossBow and n:find("cross") then
                            labelText = "Crossbow Cultist {" .. math.floor(dist) .. "m}"
                            visible = true
                        elseif espSettings.PeltTrader and n:find("pelt") then
                            labelText = "Pelt Trader {" .. math.floor(dist) .. "m}"
                            visible = true
                        end
                    end

                    if visible then
                        local pos, onScreen = Camera:WorldToViewportPoint(head.Position)
                        if onScreen then
                            data.name.Text = labelText
                            data.name.Position = Vector2.new(pos.X, pos.Y - 25)
                            data.name.Visible = true

                            local humanoid = model:FindFirstChildOfClass("Humanoid")
                            if humanoid and humanoid.Health > 0 then
                                local hp = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
                                local bw, bh = espSettings.HPBarSize.X, espSettings.HPBarSize.Y
                                local x = pos.X - bw / 2
                                local y = pos.Y - 5

                                data.hpBack.Position = Vector2.new(x, y)
                                data.hpBack.Size = Vector2.new(bw, bh)
                                data.hpBack.Visible = true

                                data.hpBar.Position = Vector2.new(x, y)
                                data.hpBar.Size = Vector2.new(bw * hp, bh)
                                data.hpBar.Color = Color3.new(1 - hp, hp, 0)
                                data.hpBar.Visible = true
                            else
                                data.hpBack.Visible = false
                                data.hpBar.Visible = false
                            end

                            if not tracers[i] then
                                tracers[i] = Drawing.new("Line")
                            end
                            local line = tracers[i]
                            line.From = screenMid - Vector2.new(0, 10)
                            line.To = Vector2.new(pos.X, pos.Y)
                            line.Color = Color3.fromRGB(255, 0, 0)
                            line.Thickness = 1
                            line.Visible = true
                            i += 1
                        else
                            data.name.Visible = false
                            data.hpBack.Visible = false
                            data.hpBar.Visible = false
                        end
                    else
                        data.name.Visible = false
                        data.hpBack.Visible = false
                        data.hpBar.Visible = false
                    end
                end
            end)
        else
            if espConnection then
                espConnection:Disconnect()
                espConnection = nil
            end
            if scanTask then
                task.cancel(scanTask)
                scanTask = nil
            end
            clearESP()
        end
    end
})

local itemNameTags = {}

tab3.create_toggle({
    name = 'Item ESP',
    flag = 'Bringlog',
    section = 'left',
    enabled = false,

    callback = function(state: boolean)
        local Workspace = game:GetService("Workspace")

        local function createItemNameTag(item)
            if itemNameTags[item] then return end
            local adornee = item:FindFirstChild("Handle") or item:FindFirstChildWhichIsA("BasePart")
            if not adornee then return end

            local tag = Instance.new("BillboardGui")
            tag.Name = "ItemNameTag"
            tag.Adornee = adornee
            tag.AlwaysOnTop = true
            tag.Size = UDim2.new(0, 100, 0, 20)
            tag.StudsOffset = Vector3.new(0, 2, 0)

            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, 0, 1, 0)
            label.BackgroundTransparency = 1
            label.Text = item.Name
            label.TextColor3 = Color3.fromRGB(255, 255, 255)
            label.TextStrokeTransparency = 0.5
            label.TextScaled = true
            label.Font = Enum.Font.SourceSansBold
            label.Parent = tag

            tag.Parent = adornee
            itemNameTags[item] = tag
        end

        local function removeAllItemNameTags()
            for item, tag in pairs(itemNameTags) do
                if tag and tag.Parent then
                    tag:Destroy()
                end
            end
            itemNameTags = {}
        end

        if state then
            for _, item in ipairs(Workspace.Items:GetChildren()) do
                if item:IsA("Model") or item:IsA("BasePart") then
                    createItemNameTag(item)
                end
            end

            Workspace.Items.ChildAdded:Connect(function(child)
                task.wait(0.1)
                if state and (child:IsA("Model") or child:IsA("BasePart")) then
                    createItemNameTag(child)
                end
            end)

            Workspace.Items.ChildRemoved:Connect(function(child)
                if itemNameTags[child] then
                    itemNameTags[child]:Destroy()
                    itemNameTags[child] = nil
                end
            end)
        else
            removeAllItemNameTags()
        end
    end
})
local UIS = game:GetService("UserInputService")

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer
local infJumpConnection = nil
local infJumpDebounce = false

tab2.create_toggle({
    name = 'Infinite Jump',
    flag = 'infjump_toggle',
    section = 'left',
    enabled = false,

    callback = function(state: boolean)
        if state then
           
            if infJumpConnection then
                infJumpConnection:Disconnect()
            end

            infJumpDebounce = false
            infJumpConnection = UserInputService.JumpRequest:Connect(function()
                if not infJumpDebounce then
                    local character = localPlayer.Character
                    if character then
                        local humanoid = character:FindFirstChildWhichIsA("Humanoid")
                        if humanoid then
                            infJumpDebounce = true
                            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                            task.wait()
                            infJumpDebounce = false
                        end
                    end
                end
            end)
        else
            
            if infJumpConnection then
                infJumpConnection:Disconnect()
                infJumpConnection = nil
            end
            infJumpDebounce = false
        end
    end
})

tab2.create_toggle({
    name = 'Fly',
    flag = 'fly',
    section = 'left',
    enabled = false,

    callback = function(state: boolean)
          local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local root = character:WaitForChild("HumanoidRootPart")
    local startcframe=root.CFrame
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

if true then
    
local player = Players.LocalPlayer
local FLYING = false

local CONTROL = {Q = 0, E = 0}

function sFLY()
    local character = player.Character or player.CharacterAdded:Wait()
    local root = character:WaitForChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")

    if humanoid then
        humanoid.JumpPower = 0
        humanoid.AutoJumpEnabled = false
    end

    local bg = Instance.new("BodyGyro", root)
    local bv = Instance.new("BodyVelocity", root)
    bg.P = 9e4
    bg.maxTorque = Vector3.new(9e9, 9e9, 9e9)
    bg.cframe = root.CFrame
    bv.velocity = Vector3.new(0, 0, 0)
    bv.maxForce = Vector3.new(9e9, 9e9, 9e9)

    FLYING = true

    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local key = input.KeyCode.Name:lower()
            if key == "e" then CONTROL.E = 2
            elseif key == "q" then CONTROL.Q = -2
            end
        end
    end)

    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local key = input.KeyCode.Name:lower()
            if key == "e" then CONTROL.E = 0
            elseif key == "q" then CONTROL.Q = 0
            end
        end
    end)

    RunService.RenderStepped:Connect(function()
    if FLYING then
        local speed = getgenv().vflyspeed or 10
        local camCF = workspace.CurrentCamera.CFrame

        local moveDir = humanoid and humanoid.MoveDirection or Vector3.new(0, 0, 0)
        local vertical = CONTROL.E + CONTROL.Q

        local camLook = camCF.LookVector -- полный вектор с вертикалью
        local camRight = Vector3.new(camCF.RightVector.X, 0, camCF.RightVector.Z)
        if camRight.Magnitude > 0 then camRight = camRight.Unit end

        local forwardAmount = moveDir:Dot(camLook.Unit)
        local rightAmount = moveDir:Dot(camRight)

        local direction = (camLook.Unit * forwardAmount) + (camRight * rightAmount)

        if vertical ~= 0 then
            direction = direction + Vector3.new(0, vertical, 0)
        end

        if direction.Magnitude > 0 then
            direction = direction.Unit
        end

        bv.Velocity = direction * speed
        bg.CFrame = camCF
    end
end)


end

function stopFLY()
    FLYING = false
    local character = player.Character
    if character then
        local root = character:FindFirstChild("HumanoidRootPart")
        if root then
            for _, obj in ipairs(root:GetChildren()) do
                if obj:IsA("BodyGyro") or obj:IsA("BodyVelocity") then
                    obj:Destroy()
                end
            end
        end
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.JumpPower = 50
            humanoid.AutoJumpEnabled = true
        end
    end
end

 end
	if state then sFLY() else stopFLY() end
    end
})
tab2.create_slider({
    name = 'Fly Speed',
    flag = 'sliderflagname',

    section = 'left',

    value = 35,
    minimum_value = 10,
    maximum_value = 1000,

    callback = function(value: number)
        getgenv().vflyspeed=value
    end
})
tab2.create_slider({
    name = 'Walkspeed',
    flag = 'flyspeed',

    section = 'left',

    value = getgenv().speedValue or 28,
    minimum_value = 10,
    maximum_value = 1000,

    callback = function(value: number)
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer



        getgenv().speedValue = value

            local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = getgenv().speedValue
            end
       
            end
})
local RunService = game:GetService("RunService")

local NoclippingConnection = nil
local Clip = true 

local function noclipOn(character)
    Clip = false
    if NoclippingConnection then
        NoclippingConnection:Disconnect()
    end
    NoclippingConnection = RunService.Stepped:Connect(function()
        if not Clip and character then
            for _, child in pairs(character:GetDescendants()) do
                if child:IsA("BasePart") and child.CanCollide == true then
                    child.CanCollide = false
                end
            end
        end
    end)
end

local function noclipOff(character)
    Clip = true
    if NoclippingConnection then
        NoclippingConnection:Disconnect()
        NoclippingConnection = nil
    end
    if character then
        for _, child in pairs(character:GetDescendants()) do
            if child:IsA("BasePart") then
                child.CanCollide = true
            end
        end
    end
end

tab2.create_toggle({
    name = "Noclip",
    flag = "noclipToggle",
    section = "left",
    enabled = false,

    callback = function(state)
        local player = game.Players.LocalPlayer
        if not player or not player.Character then return end
        if state then
            noclipOn(player.Character)
           
        else
            noclipOff(player.Character)
            
        end
    end
})

